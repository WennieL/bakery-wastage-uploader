<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wastage Data Upload Application</title>
    <!-- Load Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Load Cropper.js CSS via CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" />
    
    <style>
        /* Ensures the cropping area is visible and works correctly */
        .cropper-container {
            max-width: 100% !important;
            height: auto !important;
        }
    </style>
</head>
<body class="bg-gray-50 font-inter">
    <!-- React Component will be mounted here -->
    <div id="root"></div>

    <!-- Load React and Babel for JSX transformation -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Load Cropper.js JS via CDN (Must be loaded before the React script) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>

    <!-- The actual React/JSX application logic -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Status message component for user feedback
        const StatusMessage = ({ type, message }) => {
            let bgColor, textColor, icon;
            switch (type) {
                case 'error':
                    bgColor = 'bg-red-100';
                    textColor = 'text-red-700';
                    icon = '‚ùå';
                    break;
                case 'success':
                    bgColor = 'bg-green-100';
                    textColor = 'text-green-700';
                    icon = '‚úÖ';
                    break;
                case 'loading':
                    bgColor = 'bg-blue-100';
                    textColor = 'text-blue-700';
                    icon = '‚è≥';
                    break;
                default:
                    bgColor = 'bg-gray-100';
                    textColor = 'text-gray-700';
                    icon = '‚ÑπÔ∏è';
            }

            return (
                <div className={`p-3 rounded-lg ${bgColor} ${textColor} text-sm font-medium transition-opacity duration-300`}>
                    {icon} {message}
                </div>
            );
        };


        // Main Component: App (contains all the form logic)
        const App = () => {
            // ‚ö†Ô∏è Replace with your n8n Webhook URL (Production or Test URL)
            const WEBHOOK_URL = "https://event-tracker-nt.zeabur.app/webhook/wastage/upload"; 

            const [store, setStore] = useState("");
            const [employee, setEmployee] = useState("");
            const [comment, setComment] = useState("");
            const [photo, setPhoto] = useState(null); // Final File/Blob for upload (cropped & compressed)
            const [preview, setPreview] = useState(null); // URL used for Cropper
            const [status, setStatus] = useState({ type: 'info', message: 'Awaiting data input...' });
            const imageRef = useRef(null);
            const cropperRef = useRef(null);

            const stores = ["NT", "KT", "BC", "BB", "GP"];
            const employees = ["Ethan", "Bella", "Mia", "Leo", "Amy"];

            // Handle file selection
            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    setPhoto(null); // Clear the previous photo state
                    setPreview(url);
                    setStatus({ type: 'info', message: 'Please crop the photo to optimize the identification area.' });
                }
            };

            // Initialize Cropper
            useEffect(() => {
                // Use window.Cropper since the library is loaded via CDN
                if (preview && imageRef.current && window.Cropper) {
                    // Destroy the old Cropper instance
                    if (cropperRef.current) {
                        cropperRef.current.destroy();
                        cropperRef.current = null;
                    }
                    
                    // Create a new Cropper instance
                    // We use an event listener to ensure the image is fully loaded in the DOM
                    const initCropper = () => {
                         // Check if Cropper already exists to prevent double initialization
                        if (!cropperRef.current) {
                            cropperRef.current = new window.Cropper(imageRef.current, { 
                                aspectRatio: NaN, // Allow free aspect ratio
                                viewMode: 1, // Restrict crop box to image area
                                dragMode: "move",
                                autoCropArea: 1,
                            });
                        }
                    };
                    
                    // Attach the Cropper initialization function to the image load event
                    imageRef.current.onload = initCropper;

                }
                
                // Cleanup function: destroy Cropper on component unmount or preview change
                return () => {
                     if (cropperRef.current) {
                        cropperRef.current.destroy();
                        cropperRef.current = null;
                    }
                };
            }, [preview]);

            // Handle cropping and compression
            const handleCropAndCompress = async () => {
                if (!cropperRef.current) return;

                setStatus({ type: 'loading', message: 'Cropping and compressing image...' });
                
                const canvas = cropperRef.current.getCroppedCanvas({
                    // Limit max width to reduce file size and processing time
                    maxWidth: 1600, 
                    maxHeight: 1600,
                });

                // Compress to JPEG, 70% quality (0.7)
                const blob = await new Promise((resolve) =>
                    canvas.toBlob((b) => resolve(b), "image/jpeg", 0.7)
                );

                // Create a new File object for upload
                const newFile = new File([blob], `wastage_${Date.now()}.jpg`, { type: "image/jpeg" });
                
                // Set the final file for upload
                setPhoto(newFile);
                
                // Destroy Cropper instance, update preview to show compressed image
                cropperRef.current.destroy();
                cropperRef.current = null;
                setPreview(URL.createObjectURL(newFile)); 

                setStatus({ type: 'info', message: `‚úÖ Image cropped and compressed (${(newFile.size / 1024).toFixed(1)} KB). Please click Upload.` });
            };

            // Handle form submission
            const handleSubmit = async (e) => {
                e.preventDefault();

                if (!store || !employee) {
                    setStatus({ type: 'error', message: "üìã Please select Store and Employee." });
                    return;
                }
                if (!photo) {
                    setStatus({ type: 'error', message: "üì∏ Please select and confirm crop for the photo." });
                    return;
                }

                const formData = new FormData();
                // Additional data passed to the n8n Webhook
                formData.append("store", store); 
                formData.append("employee", employee);
                formData.append("comment", comment || "");
                
                // CRITICAL: The image file must be named 'photo'
                formData.append("photo", photo); 

                try {
                    setStatus({ type: 'loading', message: "‚è≥ Uploading and initiating AI analysis..." });
                    
                    const res = await fetch(WEBHOOK_URL, {
                        method: "POST",
                        body: formData,
                    });

                    if (res.ok) {
                        setStatus({ type: 'success', message: "‚úÖ Upload successful! Backend AI analysis has started. Data will be written to Google Sheet shortly." });
                        
                        // Clear form
                        setStore("");
                        setEmployee("");
                        setComment("");
                        setPhoto(null);
                        setPreview(null);
                    } else {
                        const errorText = await res.text();
                        const displayError = errorText.length > 100 ? errorText.substring(0, 100) + '...' : errorText;
                        setStatus({ type: 'error', message: `‚ùå Upload failed: HTTP ${res.status}. Error: ${displayError}` });
                    }
                } catch (err) {
                    console.error(err);
                    setStatus({ type: 'error', message: "‚ö†Ô∏è Network error, please check your connection." });
                }
            };

            return (
                <div className="min-h-screen bg-gray-50 flex justify-center items-center p-4">
                    <form
                        onSubmit={handleSubmit}
                        className="bg-white rounded-xl shadow-2xl p-6 md:p-8 w-full max-w-md flex flex-col gap-4 border border-gray-100"
                    >
                        <h2 className="text-2xl font-bold text-center text-gray-800">
                            üì∏ Wastage Data Upload
                        </h2>
                        <p className="text-sm text-center text-gray-500">
                            Select a photo, crop it, confirm store and employee, and start AI data analysis.
                        </p>

                        {/* Status Message */}
                        {status.message && <StatusMessage type={status.type} message={status.message} />}

                        {/* Store Dropdown */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1" htmlFor="store">Store*</label>
                            <select
                                id="store"
                                value={store}
                                onChange={(e) => setStore(e.target.value)}
                                required
                                className="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                            >
                                <option value="">Select Store</option>
                                {stores.map((s) => (
                                    <option key={s} value={s}>{s}</option>
                                ))}
                            </select>
                        </div>

                        {/* Employee Dropdown */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1" htmlFor="employee">Employee*</label>
                            <select
                                id="employee"
                                value={employee}
                                onChange={(e) => setEmployee(e.target.value)}
                                required
                                className="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                            >
                                <option value="">Select Employee</option>
                                {employees.map((e) => (
                                    <option key={e} value={e}>{e}</option>
                                ))}
                            </select>
                        </div>

                        {/* Comment */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1" htmlFor="comment">Comment</label>
                            <textarea
                                id="comment"
                                value={comment}
                                onChange={(e) => setComment(e.target.value)}
                                placeholder="e.g., Weekend inventory leftovers"
                                className="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150"
                                rows="2"
                            />
                        </div>

                        {/* Photo Input */}
                        <div>
                            <label className="block text-sm font-medium text-gray-700 mb-1" htmlFor="photoInput">Take or Select Photo (Photo)*</label>
                            <input
                                type="file"
                                id="photoInput"
                                accept="image/*"
                                capture="environment" 
                                onChange={handleFileChange}
                                className="w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                required={!photo && !preview} 
                            />
                        </div>

                        {/* Cropping Preview Area */}
                        {preview && (
                            <div className="mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
                                <p className="text-center text-sm font-semibold text-gray-700 mb-2">üì∏ Crop Area (Drag or Zoom to adjust)</p>
                                <div className="relative w-full overflow-hidden max-h-96">
                                    <img
                                        ref={imageRef}
                                        src={preview}
                                        alt="Image to Crop"
                                        className="w-full h-auto block"
                                    />
                                </div>

                                {/* Crop Button (Visible if cropperRef exists, meaning cropping is active) */}
                                {cropperRef.current && (
                                    <button
                                        type="button"
                                        onClick={handleCropAndCompress}
                                        className="mt-3 w-full py-2 px-4 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 transition duration-150"
                                    >
                                        ‚úÇÔ∏è Confirm Crop & Compress
                                    </button>
                                )}
                                
                                {/* Show final upload button after cropping */}
                                {!cropperRef.current && photo && (
                                    <p className="text-center text-xs text-green-600 mt-2">
                                        Image is ready for upload, size: {(photo.size / 1024).toFixed(1)} KB
                                    </p>
                                )}
                            </div>
                        )}
                        
                        {/* Submit Button */}
                        <button
                            type="submit"
                            disabled={!photo || status.type === 'loading' || !store || !employee}
                            className={`mt-4 w-full py-3 font-extrabold rounded-xl shadow-lg transition duration-200 ${
                                !photo || status.type === 'loading' || !store || !employee
                                    ? 'bg-gray-400 cursor-not-allowed'
                                    : 'bg-indigo-600 hover:bg-indigo-700 text-white transform hover:scale-[1.01]'
                            }`}
                        >
                            {status.type === 'loading' ? '‚è≥ Analyzing...' : 'üöÄ Upload and Start AI Analysis'}
                        </button>

                    </form>
                </div>
            );
        };

        // Render the App component to the root element
        const container = document.getElementById('root');
        // Use ReactDOM.createRoot for React 18
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
